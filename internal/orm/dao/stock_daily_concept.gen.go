// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/ocean386/stock-task/internal/orm/model"
)

func newStockDailyConcept(db *gorm.DB, opts ...gen.DOOption) stockDailyConcept {
	_stockDailyConcept := stockDailyConcept{}

	_stockDailyConcept.stockDailyConceptDo.UseDB(db, opts...)
	_stockDailyConcept.stockDailyConceptDo.UseModel(&model.StockDailyConcept{})

	tableName := _stockDailyConcept.stockDailyConceptDo.TableName()
	_stockDailyConcept.ALL = field.NewAsterisk(tableName)
	_stockDailyConcept.ConceptCode = field.NewString(tableName, "concept_code")
	_stockDailyConcept.ConceptName = field.NewString(tableName, "concept_name")
	_stockDailyConcept.UpNumber = field.NewInt64(tableName, "up_number")
	_stockDailyConcept.DownNumber = field.NewInt64(tableName, "down_number")
	_stockDailyConcept.ConceptIncreaseRate = field.NewFloat64(tableName, "concept_increase_rate")
	_stockDailyConcept.ConceptRank = field.NewInt64(tableName, "concept_rank")
	_stockDailyConcept.StockCode = field.NewString(tableName, "stock_code")
	_stockDailyConcept.StockName = field.NewString(tableName, "stock_name")
	_stockDailyConcept.IncreaseRate = field.NewFloat64(tableName, "increase_rate")
	_stockDailyConcept.TradingDate = field.NewTime(tableName, "trading_date")
	_stockDailyConcept.UpdatedAt = field.NewTime(tableName, "updated_at")

	_stockDailyConcept.fillFieldMap()

	return _stockDailyConcept
}

// stockDailyConcept 概念-每日领涨股
type stockDailyConcept struct {
	stockDailyConceptDo

	ALL                 field.Asterisk
	ConceptCode         field.String  // 概念代码
	ConceptName         field.String  // 概念名称
	UpNumber            field.Int64   // 上涨家数
	DownNumber          field.Int64   // 下跌家数
	ConceptIncreaseRate field.Float64 // 概念涨幅
	ConceptRank         field.Int64   // 涨幅排名
	StockCode           field.String  // 股票代码-领涨
	StockName           field.String  // 股票名称-领涨
	IncreaseRate        field.Float64 // 股票涨幅
	TradingDate         field.Time    // 交易日期
	UpdatedAt           field.Time    // 更新时间

	fieldMap map[string]field.Expr
}

func (s stockDailyConcept) Table(newTableName string) *stockDailyConcept {
	s.stockDailyConceptDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s stockDailyConcept) As(alias string) *stockDailyConcept {
	s.stockDailyConceptDo.DO = *(s.stockDailyConceptDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *stockDailyConcept) updateTableName(table string) *stockDailyConcept {
	s.ALL = field.NewAsterisk(table)
	s.ConceptCode = field.NewString(table, "concept_code")
	s.ConceptName = field.NewString(table, "concept_name")
	s.UpNumber = field.NewInt64(table, "up_number")
	s.DownNumber = field.NewInt64(table, "down_number")
	s.ConceptIncreaseRate = field.NewFloat64(table, "concept_increase_rate")
	s.ConceptRank = field.NewInt64(table, "concept_rank")
	s.StockCode = field.NewString(table, "stock_code")
	s.StockName = field.NewString(table, "stock_name")
	s.IncreaseRate = field.NewFloat64(table, "increase_rate")
	s.TradingDate = field.NewTime(table, "trading_date")
	s.UpdatedAt = field.NewTime(table, "updated_at")

	s.fillFieldMap()

	return s
}

func (s *stockDailyConcept) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *stockDailyConcept) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 11)
	s.fieldMap["concept_code"] = s.ConceptCode
	s.fieldMap["concept_name"] = s.ConceptName
	s.fieldMap["up_number"] = s.UpNumber
	s.fieldMap["down_number"] = s.DownNumber
	s.fieldMap["concept_increase_rate"] = s.ConceptIncreaseRate
	s.fieldMap["concept_rank"] = s.ConceptRank
	s.fieldMap["stock_code"] = s.StockCode
	s.fieldMap["stock_name"] = s.StockName
	s.fieldMap["increase_rate"] = s.IncreaseRate
	s.fieldMap["trading_date"] = s.TradingDate
	s.fieldMap["updated_at"] = s.UpdatedAt
}

func (s stockDailyConcept) clone(db *gorm.DB) stockDailyConcept {
	s.stockDailyConceptDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s stockDailyConcept) replaceDB(db *gorm.DB) stockDailyConcept {
	s.stockDailyConceptDo.ReplaceDB(db)
	return s
}

type stockDailyConceptDo struct{ gen.DO }

type IStockDailyConceptDo interface {
	gen.SubQuery
	Debug() IStockDailyConceptDo
	WithContext(ctx context.Context) IStockDailyConceptDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IStockDailyConceptDo
	WriteDB() IStockDailyConceptDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IStockDailyConceptDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IStockDailyConceptDo
	Not(conds ...gen.Condition) IStockDailyConceptDo
	Or(conds ...gen.Condition) IStockDailyConceptDo
	Select(conds ...field.Expr) IStockDailyConceptDo
	Where(conds ...gen.Condition) IStockDailyConceptDo
	Order(conds ...field.Expr) IStockDailyConceptDo
	Distinct(cols ...field.Expr) IStockDailyConceptDo
	Omit(cols ...field.Expr) IStockDailyConceptDo
	Join(table schema.Tabler, on ...field.Expr) IStockDailyConceptDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IStockDailyConceptDo
	RightJoin(table schema.Tabler, on ...field.Expr) IStockDailyConceptDo
	Group(cols ...field.Expr) IStockDailyConceptDo
	Having(conds ...gen.Condition) IStockDailyConceptDo
	Limit(limit int) IStockDailyConceptDo
	Offset(offset int) IStockDailyConceptDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IStockDailyConceptDo
	Unscoped() IStockDailyConceptDo
	Create(values ...*model.StockDailyConcept) error
	CreateInBatches(values []*model.StockDailyConcept, batchSize int) error
	Save(values ...*model.StockDailyConcept) error
	First() (*model.StockDailyConcept, error)
	Take() (*model.StockDailyConcept, error)
	Last() (*model.StockDailyConcept, error)
	Find() ([]*model.StockDailyConcept, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.StockDailyConcept, err error)
	FindInBatches(result *[]*model.StockDailyConcept, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.StockDailyConcept) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IStockDailyConceptDo
	Assign(attrs ...field.AssignExpr) IStockDailyConceptDo
	Joins(fields ...field.RelationField) IStockDailyConceptDo
	Preload(fields ...field.RelationField) IStockDailyConceptDo
	FirstOrInit() (*model.StockDailyConcept, error)
	FirstOrCreate() (*model.StockDailyConcept, error)
	FindByPage(offset int, limit int) (result []*model.StockDailyConcept, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IStockDailyConceptDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s stockDailyConceptDo) Debug() IStockDailyConceptDo {
	return s.withDO(s.DO.Debug())
}

func (s stockDailyConceptDo) WithContext(ctx context.Context) IStockDailyConceptDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s stockDailyConceptDo) ReadDB() IStockDailyConceptDo {
	return s.Clauses(dbresolver.Read)
}

func (s stockDailyConceptDo) WriteDB() IStockDailyConceptDo {
	return s.Clauses(dbresolver.Write)
}

func (s stockDailyConceptDo) Session(config *gorm.Session) IStockDailyConceptDo {
	return s.withDO(s.DO.Session(config))
}

func (s stockDailyConceptDo) Clauses(conds ...clause.Expression) IStockDailyConceptDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s stockDailyConceptDo) Returning(value interface{}, columns ...string) IStockDailyConceptDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s stockDailyConceptDo) Not(conds ...gen.Condition) IStockDailyConceptDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s stockDailyConceptDo) Or(conds ...gen.Condition) IStockDailyConceptDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s stockDailyConceptDo) Select(conds ...field.Expr) IStockDailyConceptDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s stockDailyConceptDo) Where(conds ...gen.Condition) IStockDailyConceptDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s stockDailyConceptDo) Order(conds ...field.Expr) IStockDailyConceptDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s stockDailyConceptDo) Distinct(cols ...field.Expr) IStockDailyConceptDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s stockDailyConceptDo) Omit(cols ...field.Expr) IStockDailyConceptDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s stockDailyConceptDo) Join(table schema.Tabler, on ...field.Expr) IStockDailyConceptDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s stockDailyConceptDo) LeftJoin(table schema.Tabler, on ...field.Expr) IStockDailyConceptDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s stockDailyConceptDo) RightJoin(table schema.Tabler, on ...field.Expr) IStockDailyConceptDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s stockDailyConceptDo) Group(cols ...field.Expr) IStockDailyConceptDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s stockDailyConceptDo) Having(conds ...gen.Condition) IStockDailyConceptDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s stockDailyConceptDo) Limit(limit int) IStockDailyConceptDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s stockDailyConceptDo) Offset(offset int) IStockDailyConceptDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s stockDailyConceptDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IStockDailyConceptDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s stockDailyConceptDo) Unscoped() IStockDailyConceptDo {
	return s.withDO(s.DO.Unscoped())
}

func (s stockDailyConceptDo) Create(values ...*model.StockDailyConcept) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s stockDailyConceptDo) CreateInBatches(values []*model.StockDailyConcept, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s stockDailyConceptDo) Save(values ...*model.StockDailyConcept) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s stockDailyConceptDo) First() (*model.StockDailyConcept, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyConcept), nil
	}
}

func (s stockDailyConceptDo) Take() (*model.StockDailyConcept, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyConcept), nil
	}
}

func (s stockDailyConceptDo) Last() (*model.StockDailyConcept, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyConcept), nil
	}
}

func (s stockDailyConceptDo) Find() ([]*model.StockDailyConcept, error) {
	result, err := s.DO.Find()
	return result.([]*model.StockDailyConcept), err
}

func (s stockDailyConceptDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.StockDailyConcept, err error) {
	buf := make([]*model.StockDailyConcept, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s stockDailyConceptDo) FindInBatches(result *[]*model.StockDailyConcept, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s stockDailyConceptDo) Attrs(attrs ...field.AssignExpr) IStockDailyConceptDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s stockDailyConceptDo) Assign(attrs ...field.AssignExpr) IStockDailyConceptDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s stockDailyConceptDo) Joins(fields ...field.RelationField) IStockDailyConceptDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s stockDailyConceptDo) Preload(fields ...field.RelationField) IStockDailyConceptDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s stockDailyConceptDo) FirstOrInit() (*model.StockDailyConcept, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyConcept), nil
	}
}

func (s stockDailyConceptDo) FirstOrCreate() (*model.StockDailyConcept, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyConcept), nil
	}
}

func (s stockDailyConceptDo) FindByPage(offset int, limit int) (result []*model.StockDailyConcept, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s stockDailyConceptDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s stockDailyConceptDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s stockDailyConceptDo) Delete(models ...*model.StockDailyConcept) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *stockDailyConceptDo) withDO(do gen.Dao) *stockDailyConceptDo {
	s.DO = *do.(*gen.DO)
	return s
}
