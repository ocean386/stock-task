// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/ocean386/stock-task/internal/orm/model"
)

func newStockFundRank(db *gorm.DB, opts ...gen.DOOption) stockFundRank {
	_stockFundRank := stockFundRank{}

	_stockFundRank.stockFundRankDo.UseDB(db, opts...)
	_stockFundRank.stockFundRankDo.UseModel(&model.StockFundRank{})

	tableName := _stockFundRank.stockFundRankDo.TableName()
	_stockFundRank.ALL = field.NewAsterisk(tableName)
	_stockFundRank.StockCode = field.NewString(tableName, "stock_code")
	_stockFundRank.StockName = field.NewString(tableName, "stock_name")
	_stockFundRank.PlateType = field.NewInt64(tableName, "plate_type")
	_stockFundRank.MainFund = field.NewFloat64(tableName, "main_fund")
	_stockFundRank.MainPercent = field.NewFloat64(tableName, "main_percent")
	_stockFundRank.SuperFund = field.NewFloat64(tableName, "super_fund")
	_stockFundRank.SuperPercent = field.NewFloat64(tableName, "super_percent")
	_stockFundRank.FundSortID = field.NewInt64(tableName, "fund_sort_id")
	_stockFundRank.FundPercentSortID = field.NewInt64(tableName, "fund_percent_sort_id")
	_stockFundRank.VolumeRatio = field.NewFloat64(tableName, "volume_ratio")
	_stockFundRank.TurnoverRate = field.NewFloat64(tableName, "turnover_rate")
	_stockFundRank.IncreaseRate = field.NewFloat64(tableName, "increase_rate")
	_stockFundRank.CurrentPrice = field.NewFloat64(tableName, "current_price")
	_stockFundRank.TradingDate = field.NewTime(tableName, "trading_date")
	_stockFundRank.Industry = field.NewString(tableName, "industry")
	_stockFundRank.IndustryCode = field.NewString(tableName, "industry_code")
	_stockFundRank.UpdatedAt = field.NewTime(tableName, "updated_at")

	_stockFundRank.fillFieldMap()

	return _stockFundRank
}

// stockFundRank 个股资金排行榜
type stockFundRank struct {
	stockFundRankDo

	ALL               field.Asterisk
	StockCode         field.String  // 股票代码
	StockName         field.String  // 股票名称
	PlateType         field.Int64   // 盘股类型(0-全部,1-小盘,2-中盘,3-大盘)
	MainFund          field.Float64 // 主力净流入(亿)
	MainPercent       field.Float64 // 主力净流入占比
	SuperFund         field.Float64 // 超大单净流入(亿)
	SuperPercent      field.Float64 // 超大单净流入占比
	FundSortID        field.Int64   // 净流入排名
	FundPercentSortID field.Int64   // 净占比排名
	VolumeRatio       field.Float64 // 量比
	TurnoverRate      field.Float64 // 换手
	IncreaseRate      field.Float64 // 涨幅
	CurrentPrice      field.Float64 // 现价
	TradingDate       field.Time    // 交易日期
	Industry          field.String  // 行业
	IndustryCode      field.String  // 行业代码
	UpdatedAt         field.Time    // 更新时间

	fieldMap map[string]field.Expr
}

func (s stockFundRank) Table(newTableName string) *stockFundRank {
	s.stockFundRankDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s stockFundRank) As(alias string) *stockFundRank {
	s.stockFundRankDo.DO = *(s.stockFundRankDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *stockFundRank) updateTableName(table string) *stockFundRank {
	s.ALL = field.NewAsterisk(table)
	s.StockCode = field.NewString(table, "stock_code")
	s.StockName = field.NewString(table, "stock_name")
	s.PlateType = field.NewInt64(table, "plate_type")
	s.MainFund = field.NewFloat64(table, "main_fund")
	s.MainPercent = field.NewFloat64(table, "main_percent")
	s.SuperFund = field.NewFloat64(table, "super_fund")
	s.SuperPercent = field.NewFloat64(table, "super_percent")
	s.FundSortID = field.NewInt64(table, "fund_sort_id")
	s.FundPercentSortID = field.NewInt64(table, "fund_percent_sort_id")
	s.VolumeRatio = field.NewFloat64(table, "volume_ratio")
	s.TurnoverRate = field.NewFloat64(table, "turnover_rate")
	s.IncreaseRate = field.NewFloat64(table, "increase_rate")
	s.CurrentPrice = field.NewFloat64(table, "current_price")
	s.TradingDate = field.NewTime(table, "trading_date")
	s.Industry = field.NewString(table, "industry")
	s.IndustryCode = field.NewString(table, "industry_code")
	s.UpdatedAt = field.NewTime(table, "updated_at")

	s.fillFieldMap()

	return s
}

func (s *stockFundRank) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *stockFundRank) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 17)
	s.fieldMap["stock_code"] = s.StockCode
	s.fieldMap["stock_name"] = s.StockName
	s.fieldMap["plate_type"] = s.PlateType
	s.fieldMap["main_fund"] = s.MainFund
	s.fieldMap["main_percent"] = s.MainPercent
	s.fieldMap["super_fund"] = s.SuperFund
	s.fieldMap["super_percent"] = s.SuperPercent
	s.fieldMap["fund_sort_id"] = s.FundSortID
	s.fieldMap["fund_percent_sort_id"] = s.FundPercentSortID
	s.fieldMap["volume_ratio"] = s.VolumeRatio
	s.fieldMap["turnover_rate"] = s.TurnoverRate
	s.fieldMap["increase_rate"] = s.IncreaseRate
	s.fieldMap["current_price"] = s.CurrentPrice
	s.fieldMap["trading_date"] = s.TradingDate
	s.fieldMap["industry"] = s.Industry
	s.fieldMap["industry_code"] = s.IndustryCode
	s.fieldMap["updated_at"] = s.UpdatedAt
}

func (s stockFundRank) clone(db *gorm.DB) stockFundRank {
	s.stockFundRankDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s stockFundRank) replaceDB(db *gorm.DB) stockFundRank {
	s.stockFundRankDo.ReplaceDB(db)
	return s
}

type stockFundRankDo struct{ gen.DO }

type IStockFundRankDo interface {
	gen.SubQuery
	Debug() IStockFundRankDo
	WithContext(ctx context.Context) IStockFundRankDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IStockFundRankDo
	WriteDB() IStockFundRankDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IStockFundRankDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IStockFundRankDo
	Not(conds ...gen.Condition) IStockFundRankDo
	Or(conds ...gen.Condition) IStockFundRankDo
	Select(conds ...field.Expr) IStockFundRankDo
	Where(conds ...gen.Condition) IStockFundRankDo
	Order(conds ...field.Expr) IStockFundRankDo
	Distinct(cols ...field.Expr) IStockFundRankDo
	Omit(cols ...field.Expr) IStockFundRankDo
	Join(table schema.Tabler, on ...field.Expr) IStockFundRankDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IStockFundRankDo
	RightJoin(table schema.Tabler, on ...field.Expr) IStockFundRankDo
	Group(cols ...field.Expr) IStockFundRankDo
	Having(conds ...gen.Condition) IStockFundRankDo
	Limit(limit int) IStockFundRankDo
	Offset(offset int) IStockFundRankDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IStockFundRankDo
	Unscoped() IStockFundRankDo
	Create(values ...*model.StockFundRank) error
	CreateInBatches(values []*model.StockFundRank, batchSize int) error
	Save(values ...*model.StockFundRank) error
	First() (*model.StockFundRank, error)
	Take() (*model.StockFundRank, error)
	Last() (*model.StockFundRank, error)
	Find() ([]*model.StockFundRank, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.StockFundRank, err error)
	FindInBatches(result *[]*model.StockFundRank, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.StockFundRank) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IStockFundRankDo
	Assign(attrs ...field.AssignExpr) IStockFundRankDo
	Joins(fields ...field.RelationField) IStockFundRankDo
	Preload(fields ...field.RelationField) IStockFundRankDo
	FirstOrInit() (*model.StockFundRank, error)
	FirstOrCreate() (*model.StockFundRank, error)
	FindByPage(offset int, limit int) (result []*model.StockFundRank, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IStockFundRankDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s stockFundRankDo) Debug() IStockFundRankDo {
	return s.withDO(s.DO.Debug())
}

func (s stockFundRankDo) WithContext(ctx context.Context) IStockFundRankDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s stockFundRankDo) ReadDB() IStockFundRankDo {
	return s.Clauses(dbresolver.Read)
}

func (s stockFundRankDo) WriteDB() IStockFundRankDo {
	return s.Clauses(dbresolver.Write)
}

func (s stockFundRankDo) Session(config *gorm.Session) IStockFundRankDo {
	return s.withDO(s.DO.Session(config))
}

func (s stockFundRankDo) Clauses(conds ...clause.Expression) IStockFundRankDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s stockFundRankDo) Returning(value interface{}, columns ...string) IStockFundRankDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s stockFundRankDo) Not(conds ...gen.Condition) IStockFundRankDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s stockFundRankDo) Or(conds ...gen.Condition) IStockFundRankDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s stockFundRankDo) Select(conds ...field.Expr) IStockFundRankDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s stockFundRankDo) Where(conds ...gen.Condition) IStockFundRankDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s stockFundRankDo) Order(conds ...field.Expr) IStockFundRankDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s stockFundRankDo) Distinct(cols ...field.Expr) IStockFundRankDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s stockFundRankDo) Omit(cols ...field.Expr) IStockFundRankDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s stockFundRankDo) Join(table schema.Tabler, on ...field.Expr) IStockFundRankDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s stockFundRankDo) LeftJoin(table schema.Tabler, on ...field.Expr) IStockFundRankDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s stockFundRankDo) RightJoin(table schema.Tabler, on ...field.Expr) IStockFundRankDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s stockFundRankDo) Group(cols ...field.Expr) IStockFundRankDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s stockFundRankDo) Having(conds ...gen.Condition) IStockFundRankDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s stockFundRankDo) Limit(limit int) IStockFundRankDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s stockFundRankDo) Offset(offset int) IStockFundRankDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s stockFundRankDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IStockFundRankDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s stockFundRankDo) Unscoped() IStockFundRankDo {
	return s.withDO(s.DO.Unscoped())
}

func (s stockFundRankDo) Create(values ...*model.StockFundRank) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s stockFundRankDo) CreateInBatches(values []*model.StockFundRank, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s stockFundRankDo) Save(values ...*model.StockFundRank) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s stockFundRankDo) First() (*model.StockFundRank, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockFundRank), nil
	}
}

func (s stockFundRankDo) Take() (*model.StockFundRank, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockFundRank), nil
	}
}

func (s stockFundRankDo) Last() (*model.StockFundRank, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockFundRank), nil
	}
}

func (s stockFundRankDo) Find() ([]*model.StockFundRank, error) {
	result, err := s.DO.Find()
	return result.([]*model.StockFundRank), err
}

func (s stockFundRankDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.StockFundRank, err error) {
	buf := make([]*model.StockFundRank, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s stockFundRankDo) FindInBatches(result *[]*model.StockFundRank, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s stockFundRankDo) Attrs(attrs ...field.AssignExpr) IStockFundRankDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s stockFundRankDo) Assign(attrs ...field.AssignExpr) IStockFundRankDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s stockFundRankDo) Joins(fields ...field.RelationField) IStockFundRankDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s stockFundRankDo) Preload(fields ...field.RelationField) IStockFundRankDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s stockFundRankDo) FirstOrInit() (*model.StockFundRank, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockFundRank), nil
	}
}

func (s stockFundRankDo) FirstOrCreate() (*model.StockFundRank, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockFundRank), nil
	}
}

func (s stockFundRankDo) FindByPage(offset int, limit int) (result []*model.StockFundRank, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s stockFundRankDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s stockFundRankDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s stockFundRankDo) Delete(models ...*model.StockFundRank) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *stockFundRankDo) withDO(do gen.Dao) *stockFundRankDo {
	s.DO = *do.(*gen.DO)
	return s
}
