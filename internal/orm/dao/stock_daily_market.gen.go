// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/ocean386/stock-task/internal/orm/model"
)

func newStockDailyMarket(db *gorm.DB, opts ...gen.DOOption) stockDailyMarket {
	_stockDailyMarket := stockDailyMarket{}

	_stockDailyMarket.stockDailyMarketDo.UseDB(db, opts...)
	_stockDailyMarket.stockDailyMarketDo.UseModel(&model.StockDailyMarket{})

	tableName := _stockDailyMarket.stockDailyMarketDo.TableName()
	_stockDailyMarket.ALL = field.NewAsterisk(tableName)
	_stockDailyMarket.StockCode = field.NewString(tableName, "stock_code")
	_stockDailyMarket.StockName = field.NewString(tableName, "stock_name")
	_stockDailyMarket.Turnover = field.NewFloat64(tableName, "turnover")
	_stockDailyMarket.VolumeRatio = field.NewFloat64(tableName, "volume_ratio")
	_stockDailyMarket.TurnoverRate = field.NewFloat64(tableName, "turnover_rate")
	_stockDailyMarket.IncreaseRate = field.NewFloat64(tableName, "increase_rate")
	_stockDailyMarket.Amplitude = field.NewFloat64(tableName, "amplitude")
	_stockDailyMarket.CurrentPrice = field.NewFloat64(tableName, "current_price")
	_stockDailyMarket.OpeningPrice = field.NewFloat64(tableName, "opening_price")
	_stockDailyMarket.HighestPrice = field.NewFloat64(tableName, "highest_price")
	_stockDailyMarket.LowestPrice = field.NewFloat64(tableName, "lowest_price")
	_stockDailyMarket.IncreaseRate5d = field.NewFloat64(tableName, "increase_rate_5d")
	_stockDailyMarket.IncreaseRate10d = field.NewFloat64(tableName, "increase_rate_10d")
	_stockDailyMarket.IncreaseRate20d = field.NewFloat64(tableName, "increase_rate_20d")
	_stockDailyMarket.Highest52w = field.NewFloat64(tableName, "highest_52w")
	_stockDailyMarket.Lowest52w = field.NewFloat64(tableName, "lowest_52w")
	_stockDailyMarket.Volume = field.NewFloat64(tableName, "volume")
	_stockDailyMarket.KlineType = field.NewInt64(tableName, "kline_type")
	_stockDailyMarket.TradingDate = field.NewTime(tableName, "trading_date")
	_stockDailyMarket.UpdatedAt = field.NewTime(tableName, "updated_at")

	_stockDailyMarket.fillFieldMap()

	return _stockDailyMarket
}

// stockDailyMarket 每日行情信息列表 - A股
type stockDailyMarket struct {
	stockDailyMarketDo

	ALL             field.Asterisk
	StockCode       field.String  // 股票代码
	StockName       field.String  // 股票名称
	Turnover        field.Float64 // 成交额(亿)
	VolumeRatio     field.Float64 // 量比
	TurnoverRate    field.Float64 // 换手
	IncreaseRate    field.Float64 // 涨幅
	Amplitude       field.Float64 // 振幅
	CurrentPrice    field.Float64 // 现价
	OpeningPrice    field.Float64 // 开盘
	HighestPrice    field.Float64 // 最高
	LowestPrice     field.Float64 // 最低
	IncreaseRate5d  field.Float64 // 5日涨幅
	IncreaseRate10d field.Float64 // 10日涨幅
	IncreaseRate20d field.Float64 // 20日涨幅
	Highest52w      field.Float64 // 52周最高价
	Lowest52w       field.Float64 // 52周最低价
	Volume          field.Float64 // 成交量(万手)
	KlineType       field.Int64   // K线类型(0-日K线,1-周K线,2-月K线)
	TradingDate     field.Time    // 交易日期
	UpdatedAt       field.Time    // 更新时间

	fieldMap map[string]field.Expr
}

func (s stockDailyMarket) Table(newTableName string) *stockDailyMarket {
	s.stockDailyMarketDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s stockDailyMarket) As(alias string) *stockDailyMarket {
	s.stockDailyMarketDo.DO = *(s.stockDailyMarketDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *stockDailyMarket) updateTableName(table string) *stockDailyMarket {
	s.ALL = field.NewAsterisk(table)
	s.StockCode = field.NewString(table, "stock_code")
	s.StockName = field.NewString(table, "stock_name")
	s.Turnover = field.NewFloat64(table, "turnover")
	s.VolumeRatio = field.NewFloat64(table, "volume_ratio")
	s.TurnoverRate = field.NewFloat64(table, "turnover_rate")
	s.IncreaseRate = field.NewFloat64(table, "increase_rate")
	s.Amplitude = field.NewFloat64(table, "amplitude")
	s.CurrentPrice = field.NewFloat64(table, "current_price")
	s.OpeningPrice = field.NewFloat64(table, "opening_price")
	s.HighestPrice = field.NewFloat64(table, "highest_price")
	s.LowestPrice = field.NewFloat64(table, "lowest_price")
	s.IncreaseRate5d = field.NewFloat64(table, "increase_rate_5d")
	s.IncreaseRate10d = field.NewFloat64(table, "increase_rate_10d")
	s.IncreaseRate20d = field.NewFloat64(table, "increase_rate_20d")
	s.Highest52w = field.NewFloat64(table, "highest_52w")
	s.Lowest52w = field.NewFloat64(table, "lowest_52w")
	s.Volume = field.NewFloat64(table, "volume")
	s.KlineType = field.NewInt64(table, "kline_type")
	s.TradingDate = field.NewTime(table, "trading_date")
	s.UpdatedAt = field.NewTime(table, "updated_at")

	s.fillFieldMap()

	return s
}

func (s *stockDailyMarket) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *stockDailyMarket) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 20)
	s.fieldMap["stock_code"] = s.StockCode
	s.fieldMap["stock_name"] = s.StockName
	s.fieldMap["turnover"] = s.Turnover
	s.fieldMap["volume_ratio"] = s.VolumeRatio
	s.fieldMap["turnover_rate"] = s.TurnoverRate
	s.fieldMap["increase_rate"] = s.IncreaseRate
	s.fieldMap["amplitude"] = s.Amplitude
	s.fieldMap["current_price"] = s.CurrentPrice
	s.fieldMap["opening_price"] = s.OpeningPrice
	s.fieldMap["highest_price"] = s.HighestPrice
	s.fieldMap["lowest_price"] = s.LowestPrice
	s.fieldMap["increase_rate_5d"] = s.IncreaseRate5d
	s.fieldMap["increase_rate_10d"] = s.IncreaseRate10d
	s.fieldMap["increase_rate_20d"] = s.IncreaseRate20d
	s.fieldMap["highest_52w"] = s.Highest52w
	s.fieldMap["lowest_52w"] = s.Lowest52w
	s.fieldMap["volume"] = s.Volume
	s.fieldMap["kline_type"] = s.KlineType
	s.fieldMap["trading_date"] = s.TradingDate
	s.fieldMap["updated_at"] = s.UpdatedAt
}

func (s stockDailyMarket) clone(db *gorm.DB) stockDailyMarket {
	s.stockDailyMarketDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s stockDailyMarket) replaceDB(db *gorm.DB) stockDailyMarket {
	s.stockDailyMarketDo.ReplaceDB(db)
	return s
}

type stockDailyMarketDo struct{ gen.DO }

type IStockDailyMarketDo interface {
	gen.SubQuery
	Debug() IStockDailyMarketDo
	WithContext(ctx context.Context) IStockDailyMarketDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IStockDailyMarketDo
	WriteDB() IStockDailyMarketDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IStockDailyMarketDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IStockDailyMarketDo
	Not(conds ...gen.Condition) IStockDailyMarketDo
	Or(conds ...gen.Condition) IStockDailyMarketDo
	Select(conds ...field.Expr) IStockDailyMarketDo
	Where(conds ...gen.Condition) IStockDailyMarketDo
	Order(conds ...field.Expr) IStockDailyMarketDo
	Distinct(cols ...field.Expr) IStockDailyMarketDo
	Omit(cols ...field.Expr) IStockDailyMarketDo
	Join(table schema.Tabler, on ...field.Expr) IStockDailyMarketDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IStockDailyMarketDo
	RightJoin(table schema.Tabler, on ...field.Expr) IStockDailyMarketDo
	Group(cols ...field.Expr) IStockDailyMarketDo
	Having(conds ...gen.Condition) IStockDailyMarketDo
	Limit(limit int) IStockDailyMarketDo
	Offset(offset int) IStockDailyMarketDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IStockDailyMarketDo
	Unscoped() IStockDailyMarketDo
	Create(values ...*model.StockDailyMarket) error
	CreateInBatches(values []*model.StockDailyMarket, batchSize int) error
	Save(values ...*model.StockDailyMarket) error
	First() (*model.StockDailyMarket, error)
	Take() (*model.StockDailyMarket, error)
	Last() (*model.StockDailyMarket, error)
	Find() ([]*model.StockDailyMarket, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.StockDailyMarket, err error)
	FindInBatches(result *[]*model.StockDailyMarket, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.StockDailyMarket) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IStockDailyMarketDo
	Assign(attrs ...field.AssignExpr) IStockDailyMarketDo
	Joins(fields ...field.RelationField) IStockDailyMarketDo
	Preload(fields ...field.RelationField) IStockDailyMarketDo
	FirstOrInit() (*model.StockDailyMarket, error)
	FirstOrCreate() (*model.StockDailyMarket, error)
	FindByPage(offset int, limit int) (result []*model.StockDailyMarket, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IStockDailyMarketDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s stockDailyMarketDo) Debug() IStockDailyMarketDo {
	return s.withDO(s.DO.Debug())
}

func (s stockDailyMarketDo) WithContext(ctx context.Context) IStockDailyMarketDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s stockDailyMarketDo) ReadDB() IStockDailyMarketDo {
	return s.Clauses(dbresolver.Read)
}

func (s stockDailyMarketDo) WriteDB() IStockDailyMarketDo {
	return s.Clauses(dbresolver.Write)
}

func (s stockDailyMarketDo) Session(config *gorm.Session) IStockDailyMarketDo {
	return s.withDO(s.DO.Session(config))
}

func (s stockDailyMarketDo) Clauses(conds ...clause.Expression) IStockDailyMarketDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s stockDailyMarketDo) Returning(value interface{}, columns ...string) IStockDailyMarketDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s stockDailyMarketDo) Not(conds ...gen.Condition) IStockDailyMarketDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s stockDailyMarketDo) Or(conds ...gen.Condition) IStockDailyMarketDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s stockDailyMarketDo) Select(conds ...field.Expr) IStockDailyMarketDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s stockDailyMarketDo) Where(conds ...gen.Condition) IStockDailyMarketDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s stockDailyMarketDo) Order(conds ...field.Expr) IStockDailyMarketDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s stockDailyMarketDo) Distinct(cols ...field.Expr) IStockDailyMarketDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s stockDailyMarketDo) Omit(cols ...field.Expr) IStockDailyMarketDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s stockDailyMarketDo) Join(table schema.Tabler, on ...field.Expr) IStockDailyMarketDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s stockDailyMarketDo) LeftJoin(table schema.Tabler, on ...field.Expr) IStockDailyMarketDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s stockDailyMarketDo) RightJoin(table schema.Tabler, on ...field.Expr) IStockDailyMarketDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s stockDailyMarketDo) Group(cols ...field.Expr) IStockDailyMarketDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s stockDailyMarketDo) Having(conds ...gen.Condition) IStockDailyMarketDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s stockDailyMarketDo) Limit(limit int) IStockDailyMarketDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s stockDailyMarketDo) Offset(offset int) IStockDailyMarketDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s stockDailyMarketDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IStockDailyMarketDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s stockDailyMarketDo) Unscoped() IStockDailyMarketDo {
	return s.withDO(s.DO.Unscoped())
}

func (s stockDailyMarketDo) Create(values ...*model.StockDailyMarket) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s stockDailyMarketDo) CreateInBatches(values []*model.StockDailyMarket, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s stockDailyMarketDo) Save(values ...*model.StockDailyMarket) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s stockDailyMarketDo) First() (*model.StockDailyMarket, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyMarket), nil
	}
}

func (s stockDailyMarketDo) Take() (*model.StockDailyMarket, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyMarket), nil
	}
}

func (s stockDailyMarketDo) Last() (*model.StockDailyMarket, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyMarket), nil
	}
}

func (s stockDailyMarketDo) Find() ([]*model.StockDailyMarket, error) {
	result, err := s.DO.Find()
	return result.([]*model.StockDailyMarket), err
}

func (s stockDailyMarketDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.StockDailyMarket, err error) {
	buf := make([]*model.StockDailyMarket, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s stockDailyMarketDo) FindInBatches(result *[]*model.StockDailyMarket, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s stockDailyMarketDo) Attrs(attrs ...field.AssignExpr) IStockDailyMarketDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s stockDailyMarketDo) Assign(attrs ...field.AssignExpr) IStockDailyMarketDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s stockDailyMarketDo) Joins(fields ...field.RelationField) IStockDailyMarketDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s stockDailyMarketDo) Preload(fields ...field.RelationField) IStockDailyMarketDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s stockDailyMarketDo) FirstOrInit() (*model.StockDailyMarket, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyMarket), nil
	}
}

func (s stockDailyMarketDo) FirstOrCreate() (*model.StockDailyMarket, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyMarket), nil
	}
}

func (s stockDailyMarketDo) FindByPage(offset int, limit int) (result []*model.StockDailyMarket, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s stockDailyMarketDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s stockDailyMarketDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s stockDailyMarketDo) Delete(models ...*model.StockDailyMarket) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *stockDailyMarketDo) withDO(do gen.Dao) *stockDailyMarketDo {
	s.DO = *do.(*gen.DO)
	return s
}
