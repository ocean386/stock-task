// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/ocean386/stock-task/internal/orm/model"
)

func newStockDailyIndustry(db *gorm.DB, opts ...gen.DOOption) stockDailyIndustry {
	_stockDailyIndustry := stockDailyIndustry{}

	_stockDailyIndustry.stockDailyIndustryDo.UseDB(db, opts...)
	_stockDailyIndustry.stockDailyIndustryDo.UseModel(&model.StockDailyIndustry{})

	tableName := _stockDailyIndustry.stockDailyIndustryDo.TableName()
	_stockDailyIndustry.ALL = field.NewAsterisk(tableName)
	_stockDailyIndustry.IndustryName = field.NewString(tableName, "industry_name")
	_stockDailyIndustry.IndustryCode = field.NewString(tableName, "industry_code")
	_stockDailyIndustry.UpNumber = field.NewInt64(tableName, "up_number")
	_stockDailyIndustry.DownNumber = field.NewInt64(tableName, "down_number")
	_stockDailyIndustry.IndustryIncreaseRate = field.NewFloat64(tableName, "industry_increase_rate")
	_stockDailyIndustry.IndustryRank = field.NewInt64(tableName, "industry_rank")
	_stockDailyIndustry.StockCode = field.NewString(tableName, "stock_code")
	_stockDailyIndustry.StockName = field.NewString(tableName, "stock_name")
	_stockDailyIndustry.IncreaseRate = field.NewFloat64(tableName, "increase_rate")
	_stockDailyIndustry.TradingDate = field.NewTime(tableName, "trading_date")
	_stockDailyIndustry.UpdatedAt = field.NewTime(tableName, "updated_at")

	_stockDailyIndustry.fillFieldMap()

	return _stockDailyIndustry
}

// stockDailyIndustry 行业-每日领涨股
type stockDailyIndustry struct {
	stockDailyIndustryDo

	ALL                  field.Asterisk
	IndustryName         field.String  // 行业名称
	IndustryCode         field.String  // 行业代码
	UpNumber             field.Int64   // 上涨家数
	DownNumber           field.Int64   // 下跌家数
	IndustryIncreaseRate field.Float64 // 行业涨幅
	IndustryRank         field.Int64   // 涨幅排名
	StockCode            field.String  // 股票代码-领涨
	StockName            field.String  // 股票名称-领涨
	IncreaseRate         field.Float64 // 股票涨幅
	TradingDate          field.Time    // 交易日期
	UpdatedAt            field.Time    // 更新时间

	fieldMap map[string]field.Expr
}

func (s stockDailyIndustry) Table(newTableName string) *stockDailyIndustry {
	s.stockDailyIndustryDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s stockDailyIndustry) As(alias string) *stockDailyIndustry {
	s.stockDailyIndustryDo.DO = *(s.stockDailyIndustryDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *stockDailyIndustry) updateTableName(table string) *stockDailyIndustry {
	s.ALL = field.NewAsterisk(table)
	s.IndustryName = field.NewString(table, "industry_name")
	s.IndustryCode = field.NewString(table, "industry_code")
	s.UpNumber = field.NewInt64(table, "up_number")
	s.DownNumber = field.NewInt64(table, "down_number")
	s.IndustryIncreaseRate = field.NewFloat64(table, "industry_increase_rate")
	s.IndustryRank = field.NewInt64(table, "industry_rank")
	s.StockCode = field.NewString(table, "stock_code")
	s.StockName = field.NewString(table, "stock_name")
	s.IncreaseRate = field.NewFloat64(table, "increase_rate")
	s.TradingDate = field.NewTime(table, "trading_date")
	s.UpdatedAt = field.NewTime(table, "updated_at")

	s.fillFieldMap()

	return s
}

func (s *stockDailyIndustry) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *stockDailyIndustry) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 11)
	s.fieldMap["industry_name"] = s.IndustryName
	s.fieldMap["industry_code"] = s.IndustryCode
	s.fieldMap["up_number"] = s.UpNumber
	s.fieldMap["down_number"] = s.DownNumber
	s.fieldMap["industry_increase_rate"] = s.IndustryIncreaseRate
	s.fieldMap["industry_rank"] = s.IndustryRank
	s.fieldMap["stock_code"] = s.StockCode
	s.fieldMap["stock_name"] = s.StockName
	s.fieldMap["increase_rate"] = s.IncreaseRate
	s.fieldMap["trading_date"] = s.TradingDate
	s.fieldMap["updated_at"] = s.UpdatedAt
}

func (s stockDailyIndustry) clone(db *gorm.DB) stockDailyIndustry {
	s.stockDailyIndustryDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s stockDailyIndustry) replaceDB(db *gorm.DB) stockDailyIndustry {
	s.stockDailyIndustryDo.ReplaceDB(db)
	return s
}

type stockDailyIndustryDo struct{ gen.DO }

type IStockDailyIndustryDo interface {
	gen.SubQuery
	Debug() IStockDailyIndustryDo
	WithContext(ctx context.Context) IStockDailyIndustryDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IStockDailyIndustryDo
	WriteDB() IStockDailyIndustryDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IStockDailyIndustryDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IStockDailyIndustryDo
	Not(conds ...gen.Condition) IStockDailyIndustryDo
	Or(conds ...gen.Condition) IStockDailyIndustryDo
	Select(conds ...field.Expr) IStockDailyIndustryDo
	Where(conds ...gen.Condition) IStockDailyIndustryDo
	Order(conds ...field.Expr) IStockDailyIndustryDo
	Distinct(cols ...field.Expr) IStockDailyIndustryDo
	Omit(cols ...field.Expr) IStockDailyIndustryDo
	Join(table schema.Tabler, on ...field.Expr) IStockDailyIndustryDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IStockDailyIndustryDo
	RightJoin(table schema.Tabler, on ...field.Expr) IStockDailyIndustryDo
	Group(cols ...field.Expr) IStockDailyIndustryDo
	Having(conds ...gen.Condition) IStockDailyIndustryDo
	Limit(limit int) IStockDailyIndustryDo
	Offset(offset int) IStockDailyIndustryDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IStockDailyIndustryDo
	Unscoped() IStockDailyIndustryDo
	Create(values ...*model.StockDailyIndustry) error
	CreateInBatches(values []*model.StockDailyIndustry, batchSize int) error
	Save(values ...*model.StockDailyIndustry) error
	First() (*model.StockDailyIndustry, error)
	Take() (*model.StockDailyIndustry, error)
	Last() (*model.StockDailyIndustry, error)
	Find() ([]*model.StockDailyIndustry, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.StockDailyIndustry, err error)
	FindInBatches(result *[]*model.StockDailyIndustry, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.StockDailyIndustry) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IStockDailyIndustryDo
	Assign(attrs ...field.AssignExpr) IStockDailyIndustryDo
	Joins(fields ...field.RelationField) IStockDailyIndustryDo
	Preload(fields ...field.RelationField) IStockDailyIndustryDo
	FirstOrInit() (*model.StockDailyIndustry, error)
	FirstOrCreate() (*model.StockDailyIndustry, error)
	FindByPage(offset int, limit int) (result []*model.StockDailyIndustry, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IStockDailyIndustryDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s stockDailyIndustryDo) Debug() IStockDailyIndustryDo {
	return s.withDO(s.DO.Debug())
}

func (s stockDailyIndustryDo) WithContext(ctx context.Context) IStockDailyIndustryDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s stockDailyIndustryDo) ReadDB() IStockDailyIndustryDo {
	return s.Clauses(dbresolver.Read)
}

func (s stockDailyIndustryDo) WriteDB() IStockDailyIndustryDo {
	return s.Clauses(dbresolver.Write)
}

func (s stockDailyIndustryDo) Session(config *gorm.Session) IStockDailyIndustryDo {
	return s.withDO(s.DO.Session(config))
}

func (s stockDailyIndustryDo) Clauses(conds ...clause.Expression) IStockDailyIndustryDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s stockDailyIndustryDo) Returning(value interface{}, columns ...string) IStockDailyIndustryDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s stockDailyIndustryDo) Not(conds ...gen.Condition) IStockDailyIndustryDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s stockDailyIndustryDo) Or(conds ...gen.Condition) IStockDailyIndustryDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s stockDailyIndustryDo) Select(conds ...field.Expr) IStockDailyIndustryDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s stockDailyIndustryDo) Where(conds ...gen.Condition) IStockDailyIndustryDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s stockDailyIndustryDo) Order(conds ...field.Expr) IStockDailyIndustryDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s stockDailyIndustryDo) Distinct(cols ...field.Expr) IStockDailyIndustryDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s stockDailyIndustryDo) Omit(cols ...field.Expr) IStockDailyIndustryDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s stockDailyIndustryDo) Join(table schema.Tabler, on ...field.Expr) IStockDailyIndustryDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s stockDailyIndustryDo) LeftJoin(table schema.Tabler, on ...field.Expr) IStockDailyIndustryDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s stockDailyIndustryDo) RightJoin(table schema.Tabler, on ...field.Expr) IStockDailyIndustryDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s stockDailyIndustryDo) Group(cols ...field.Expr) IStockDailyIndustryDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s stockDailyIndustryDo) Having(conds ...gen.Condition) IStockDailyIndustryDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s stockDailyIndustryDo) Limit(limit int) IStockDailyIndustryDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s stockDailyIndustryDo) Offset(offset int) IStockDailyIndustryDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s stockDailyIndustryDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IStockDailyIndustryDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s stockDailyIndustryDo) Unscoped() IStockDailyIndustryDo {
	return s.withDO(s.DO.Unscoped())
}

func (s stockDailyIndustryDo) Create(values ...*model.StockDailyIndustry) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s stockDailyIndustryDo) CreateInBatches(values []*model.StockDailyIndustry, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s stockDailyIndustryDo) Save(values ...*model.StockDailyIndustry) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s stockDailyIndustryDo) First() (*model.StockDailyIndustry, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyIndustry), nil
	}
}

func (s stockDailyIndustryDo) Take() (*model.StockDailyIndustry, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyIndustry), nil
	}
}

func (s stockDailyIndustryDo) Last() (*model.StockDailyIndustry, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyIndustry), nil
	}
}

func (s stockDailyIndustryDo) Find() ([]*model.StockDailyIndustry, error) {
	result, err := s.DO.Find()
	return result.([]*model.StockDailyIndustry), err
}

func (s stockDailyIndustryDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.StockDailyIndustry, err error) {
	buf := make([]*model.StockDailyIndustry, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s stockDailyIndustryDo) FindInBatches(result *[]*model.StockDailyIndustry, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s stockDailyIndustryDo) Attrs(attrs ...field.AssignExpr) IStockDailyIndustryDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s stockDailyIndustryDo) Assign(attrs ...field.AssignExpr) IStockDailyIndustryDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s stockDailyIndustryDo) Joins(fields ...field.RelationField) IStockDailyIndustryDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s stockDailyIndustryDo) Preload(fields ...field.RelationField) IStockDailyIndustryDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s stockDailyIndustryDo) FirstOrInit() (*model.StockDailyIndustry, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyIndustry), nil
	}
}

func (s stockDailyIndustryDo) FirstOrCreate() (*model.StockDailyIndustry, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.StockDailyIndustry), nil
	}
}

func (s stockDailyIndustryDo) FindByPage(offset int, limit int) (result []*model.StockDailyIndustry, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s stockDailyIndustryDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s stockDailyIndustryDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s stockDailyIndustryDo) Delete(models ...*model.StockDailyIndustry) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *stockDailyIndustryDo) withDO(do gen.Dao) *stockDailyIndustryDo {
	s.DO = *do.(*gen.DO)
	return s
}
